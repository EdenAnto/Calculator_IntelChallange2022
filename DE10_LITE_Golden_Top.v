
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module DE10_LITE_Golden_Top(

	//////////// CLOCK //////////
	input 		          		ADC_CLK_10,
	input 		          		MAX10_CLK1_50,
	input 		          		MAX10_CLK2_50,

	//////////// SDRAM //////////
	output		    [12:0]		DRAM_ADDR,
	output		     [1:0]		DRAM_BA,
	output		          		DRAM_CAS_N,
	output		          		DRAM_CKE,
	output		          		DRAM_CLK,
	output		          		DRAM_CS_N,
	inout 		    [15:0]		DRAM_DQ,
	output		          		DRAM_LDQM,
	output		          		DRAM_RAS_N,
	output		          		DRAM_UDQM,
	output		          		DRAM_WE_N,

	//////////// SEG7 //////////
	output 		     [7:0]		HEX0,
	output		     [7:0]		HEX1,
	output		     [7:0]		HEX2,
	output		     [7:0]		HEX3,
	output		     [7:0]		HEX4,
	output		     [7:0]		HEX5,

	//////////// KEY //////////
	input 		     [1:0]		KEY,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// VGA //////////
	output		     [3:0]		VGA_B,
	output		     [3:0]		VGA_G,
	output		          		VGA_HS,
	output		     [3:0]		VGA_R,
	output		          		VGA_VS,

	//////////// Accelerometer //////////
	output		          		GSENSOR_CS_N,
	input 		     [2:1]		GSENSOR_INT,
	output		          		GSENSOR_SCLK,
	inout 		          		GSENSOR_SDI,
	inout 		          		GSENSOR_SDO,

	//////////// Arduino //////////
	inout 		    [15:0]		ARDUINO_IO,
	inout 		          		ARDUINO_RESET_N,

	//////////// GPIO, GPIO connect to GPIO Default //////////
	inout 		    [35:0]		GPIO
	);



//=======================================================
//  REG/WIRE declarations
//=======================================================
	reg	[9:0] Answer;
	reg	[5:0] Residue;
	reg	[4:0] ErrorFlag,NegFlag;
	wire	[3:0] line1,line2,line3,line4,line5,Sum1DigAns,Sum2DigAns;
	wire	[4:0] CompAns,CompRes,SumDigitsAns;
	wire	[9:0] add_answer,sub_answer,Nsub_answer,multi_answer,TAQ,IntegralComPart;
	wire	[8:0] add,sub,Nsub,DivQ,DivR;
	wire	[6:0] AvQ;
	wire	[5:0] A,B;
	wire 			cout_adder,flag,TAR,AvR,IntegralResidue,cout_subber,Ncout_subber;

//=======================================================
//  Structural coding
//=======================================================

ProCalc pc(KEY[1],SW[5:0],KEY[0],flag,A,B);

Full_Adder_Sub adder1(.a(A),.b(B),.op(0),.s(add),.cout(cout_adder));
Full_Adder_Sub subber(.a(A),.b(B),.op(1),.s(sub),.cout(cout_subber));
Multi2    l3(.a(A),.b(B),.s(multi_answer));
Divider6 l4(.A(A),.B(B),.Q(DivQ),.R(DivR));
Average	A1(.num1(A),.num2(B),.QAverage(AvQ),.RAverage(AvR));
TriangleArea TA1(.num1(A),.num2(B),.QArea(TAQ),.RArea(TAR));
IntegralX IX1(.num1(A),.num2(B),.ComPart(IntegralComPart),.Residue(IntegralResidue));
componentConnect cC1(.num1(A),.num2(B),.answer(CompAns),.residue(CompRes));
Full_Adder_Sub Nsubber(.a(B),.b(A),.op(1),.s(Nsub),.cout(Ncout_subber));

SumDigit s1(A,Sum1DigAns);
SumDigit s2(B,Sum2DigAns);
Full_Adder_Sub adder2(.a(Sum1DigAns),.b(Sum2DigAns),.op(0),.s(SumDigitsAns));

assign add_answer[8:0] = add;
assign add_answer[9] = cout_adder;
assign sub_answer[8:0] = sub;
assign Nsub_answer[8:0] = Nsub;


always
begin
if (SW[9:6]==0)
begin
Answer=0;
Residue=0;
NegFlag=0;
end

else
begin
ErrorFlag=16;
	
if (flag)
begin
	case(SW[9:6])
		4'b0001:begin
					NegFlag=0;
					Residue=0;
					Answer= add_answer;
					end
			  
		4'b0010:begin
					Residue=0;
					if(B>A)
						begin
						if (Nsub_answer>99)
							begin
								Answer=0;
								ErrorFlag=14;
								NegFlag=0;
							end
						else
						begin
							Answer=Nsub_answer;
							NegFlag=4'hA;
						end
					end
					else
						begin
							Answer= sub_answer;
							NegFlag=0;
						end
					end
		4'b0011:begin
					Residue=0;
					Answer= multi_answer;
					NegFlag=0;
					end
				
		4'b0100:begin
					if(B==0)
						begin
						Answer= 0;
						Residue=0;
						ErrorFlag=14;
						NegFlag=0;
						end
					else
						begin
						Answer =DivQ;
						Residue=DivR;
						NegFlag=0;
					end
					end
		4'b0101:begin
					Answer =AvQ;
					Residue=AvR;
					NegFlag=0;
				 end
		4'b0110:begin
					Answer =TAQ;
					Residue=TAR;
					NegFlag=0;
				 end
		4'b0111:begin
					Answer =IntegralComPart;
					Residue=IntegralResidue;
					NegFlag=0;
				  end
		4'b1000:begin
					Answer =CompAns;
					Residue=CompRes;
					NegFlag=0;
				  end
		4'b1001:begin
				  Answer= SumDigitsAns;
				  Residue=0;
				  NegFlag=0;
				  end
		4'b1010:begin
				  Residue=0;
				  NegFlag=0;
				  Answer= (Sum1DigAns>Sum2DigAns)?  A:B;
				  Residue= (Sum1DigAns==Sum2DigAns)?  A:0;

				  end
		4'b1011:begin
				  Answer= A|B;
				  Residue=0;
				  NegFlag=0;
				  end
		4'b1100:begin
			     Answer= A&B;
				  Residue=0;
				  NegFlag=0;
				  end
		4'b1101:begin
				  Answer= A^B;
				  Residue=0;
				  NegFlag=0;
				  end
	endcase
end


if(~KEY[1])
begin 
		Answer=0; 
		Residue=0;
		end
end
end
assign LEDR=SW;
NumTo7Segment N1(Answer,line1,line2,line3);
NumTo7Segment N2(.num(Residue),.ans10(line4),.ans1(line5));

HEXDRV H3(line3,HEX3);
HEXDRV H4(line2,HEX4);
HEXDRV H5(line1|NegFlag,HEX5);

HEXDRV H0(line5,HEX0);
HEXDRV H1(line4,HEX1);

HEXDRV H2(ErrorFlag,HEX2);

endmodule
